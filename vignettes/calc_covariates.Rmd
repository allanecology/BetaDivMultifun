---
title: "prepare_covariates"
author: "noelleschenk"
date: "April 16, 2019"
output: html_document
---

- PCA of soils

## Normalisation
scale the columns which are neither binary nor factors. Scaled by centering around 0 (substracting the mean) and dividing by standard deviation.
```{r}
# create scaling vector T/F of which columns to scale in pcr
scalecols <- c("Clay", "Fine.Silt", "Medium.Silt", "Coarse.Silt", "Fine.Sand", "Medium.Sand", "Coarse.Sand", "pH", "Soil.depth", "TWI")
glsoil[, (scalecols) := lapply(.SD, function(x) scale(x, center = T)), .SDcols = scalecols]
```


Could be done within PCA computation with parameter `scale = TRUE`.
```{r}
mysubset <- names(glsoil)[!names(glsoil) %in% c("Plotn", "Soil.type")]
```
*note* : The binary categoric columns are not affected by this.
```{r}
plot(glsoil$Rendzina)
points(glsoil$Braunerde)
points(glsoil$Pelosol)
points(glsoil$Pseudogley)
points(glsoil$Erdniedermoor)
points(glsoil$Gley)
points(glsoil$Mulmniedermoor)
points(glsoil$Parabraunerde)
points(glsoil$Fahlerde)
```


## soil PCA
```{r}
# Plot information is taken as rownames of a data.frame (instead of data.table).
pc_glsoil <- as.data.frame(glsoil[,-1])
rownames(pc_glsoil) <- glsoil$Plotn
rm(glsoil)

# run the pca
pca_from_glsoil <- prcomp(pc_glsoil[, !(names(pc_glsoil) %in% "Soil.type")], scale = F)
plot(pca_from_glsoil) 
```
The first 4 axis would make sense if the dimensionality would need to be reduced a lot. 

However, here it is not that much about reducing dimensionality, but taking out unnecessary variables. Therefore, Taking PC1 to 17 is suitable, as PC18 and 19 do not add any more information.
```{r}
# first 4 axis would make sense
summary(pca_from_glsoil)
```

### PCA insights
```{r, eval=F}
# color by soil type
ggplot2::autoplot(pca_from_glsoil, data = pc_glsoil, colour = 'Soil.type')
ggplot2::autoplot(pca_from_glsoil, data = pc_glsoil, colour = 'Soil.depth')

ggplot2::autoplot(pca_from_glsoil, data = pc_glsoil, loadings = TRUE, loadings.colour = 'darkgray', loadings.label = TRUE, loadings.label.size = 2)
```

```{r, eval=F}
ggplot2::autoplot(pca_from_glsoil, x=3, y=4, data=pc_glsoil, colour="Soil.type")
ggplot2::autoplot(pca_from_glsoil, x=3, y=4, data=pc_glsoil, colour="pH")
```

### Component selection
Components 1 to 17 (as argued above).
```{r}
pca_from_glsoil <- pca_from_glsoil$x[, 1:17]
```

## Computation of Dissimilarity Matrices
With euclidian distance : `edis_glsoil`
With betadiversity : `beta_glsoil`.

*note* beta.pair.abund can not handle negative abundance values. Therefore, data needs to be centered around 0 instead of centered around 0. However, max is `r max(pca_from_glsoil)` and min is `r min(pca_from_glsoil)`. Would need an "abundance" value which makes sense.

```{r}
# welect plot set? #NEW!
# select from matrix
pca_from_glsoil <- pca_from_glsoil[which(rownames(pca_from_glsoil) %in% plotNAset), ]
pca_from_glsoil <- pca_from_glsoil[which(rownames(pca_from_glsoil) != "HEG31"), ]

# compute dissimilarities for all principal components I got (10) (euclidian distance)
edis_glsoil <- vegan::vegdist(pca_from_glsoil, method = "euclid")

#TODO : if I want to calc beta, I need to find good solution for handling negative values.
# beta_glsoil <- betapart::beta.pair.abund(pca_from_glsoil)
```

## Cleaning for GDM
```{r}
# prepare for gdm (the desired format)
edis_glsoil <- as.matrix(edis_glsoil)
# save as RDS
# saveRDS(edis_glsoil, file="soil_covariate.RDS")

# select Plots for the analysis
# edis_glsoil <- cbind("Plot" = seq(1,130), edis_glsoil)

# CLEANING away all I don't need to run gdm
rm(pca_from_glsoil); rm(pc_glsoil) ; rm(mysubset); rm(stype)
# glsoil_unscaled is used for gap-filling and therefore not deleted here.
```


# Plot isolation

#TODO add more covariates