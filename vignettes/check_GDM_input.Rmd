---
title: "run GDM"
author: "Noelle Schenk"
date: "June 21, 2019"
output: html_document
---
Requirements : 
- script is runned right after `prepare_and_run_GDM.Rmd`. Requires its output `gdminput`.
    - note that `gdminput` is also saved as .csv and .Rds from the above mentioned script.

The script calculates euclidean distances (simple substraction) of the covariates and LUI as well as the geographic distance based on coordinates and forms a table with all distances. A correlation plot is produced and a linear model fitted and both are saved. Variance inflation of the linear model is calculated and saved.

Output : 
- correlation plot `vignettes/out/<modelname>_corrplot_before_gdm.pdf`
- linear model output `vignettes/out/<modelname>_linear_model_before_gdm.Rds`
- variance inflation `out/<modelname>_vif_before_gdm.txt`
- linear model plot `vignettes/out/<modelname>_linear_model_directions.pdf`

```{r}
#TODO check if something from old code is still usable, comment well new code

# first run prepare_and_run_GDM
checkgdminput <- data.table::copy(gdminput)
# checkgdminput$rown <- rownames(checkgdminput)
checkgdminput <- data.table(checkgdminput)

# calc euclidean distance between each predictor pair of checkgdminput
dists <- colnames(checkgdminput)[grep("beta", colnames(checkgdminput))]
dists <- grep("s2.", dists, value = T)
checkgdminput[, (dists) := NULL]
checkgdminput[, weights := NULL]

# LUI
luicols <- grep(paste(lui, collapse="|"), colnames(checkgdminput), value=TRUE)
if(length(grep("Gstd", lui)) > 1){
  print("lui components")
  checkgdminput[, Gstd := s1.Gstd - s2.Gstd]
  checkgdminput[, Mstd := s1.Mstd - s2.Mstd]
  checkgdminput[, Fstd := s1.Fstd - s2.Fstd]
  checkgdminput[, deltaGstd := s1.deltaGstd - s2.deltaGstd]
  checkgdminput[, deltaMstd := s1.deltaMstd - s2.deltaMstd]
  checkgdminput[, deltaFstd := s1.deltaFstd - s2.deltaFstd]
  checkgdminput[, (luicols) := NULL]
}
#TODO add if clause for LUI

checkgdminput[, geosphere_distgeo := geosphere::distGeo(p1 = as.matrix(checkgdminput[, .(s1.yCoord, s1.xCoord)]), 
                                                      p2 = as.matrix(checkgdminput[, .(s2.yCoord, s2.xCoord)]))]
geocol <- grep("Coord", colnames(checkgdminput), value = T)
checkgdminput[, (geocol) := NULL]
checkgdminput[, s2.geosphere_distgeo := NULL]

# predictors
checkgdminput[, edis_soil := s1.edis_soil - s2.edis_soil]
checkgdminput[, plot_isolation := s1.plot_isolation - s2.plot_isolation]
del <- c("s1.edis_soil", "s2.edis_soil", "s1.plot_isolation", "s2.plot_isolation")
checkgdminput[, (del) := NULL]

# rename s1
colnames(checkgdminput) <- gsub("s1.", "", colnames(checkgdminput))

## correlation plot
# name : modelname "_corrplot_before_gdm.pdf"
m <- cor(checkgdminput)
pdf(paste("vignettes/out/", modelname, "_corrplot_before_gdm.pdf", sep = ""), paper = "a4r")
corrplot::corrplot(m, type = "lower", addCoef.col = "black", method = "color", diag = F, tl.srt = 50, tl.col = "black", order = "hclust", tl.cex = 0.4, cl.cex = 0.3, number.cex = 0.3)
dev.off()

m[m < 0.5 & m > -0.5] <- 0
corrplot::corrplot(m, type = "lower", addCoef.col = "black", method = "circle", diag = F, tl.srt = 50, tl.col = "black", order = "hclust", tl.cex = 0.4, cl.cex = 0.3, number.cex = 0.3)


## variance inflation in linear model
# generate model
mod <- paste("distance ~ " ,paste(colnames(checkgdminput)[!colnames(checkgdminput) %in% c("distance")], collapse = " + "))
m1 <- lm(formula = formula(mod), data = checkgdminput)
# save linear model
saveRDS(m1, file = paste("vignettes/out/", modelname, "_linear_model_before_gdm.Rds", sep = ""))

vif_output <- car::vif(m1)
vif_output[which(vif_output > 5)]
# vif_output[which(vif_output[, "GVIF"] > 5),]
capture.output(mod,
               vif_output[which(vif_output > 5)],
               file = paste("vignettes/out/", modelname, "_vif_before_gdm.txt", sep = ""))

# plot linear model
m1$coefficients
test <- summary(m1)
coefs <- test$coefficients
coefs <- data.table(coefs)
coefs[, names := rownames(test$coefficients)]
coefs[`Pr(>|t|)` < 0.05, pval_symbol := "*"]
coefs[`Pr(>|t|)` > 0.05, pval_symbol := ""]

linplot <- ggplot(coefs, aes(x = names, y = Estimate)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  geom_text(aes(label=pval_symbol), y=0.4, color="black", size=3.5) +
  geom_errorbar(aes(ymin=Estimate-`Std. Error`, ymax=Estimate+`Std. Error`), width=.2, color = "red") +
  background_grid() +
  ggtitle(modelname) +
  ylab("linear model estimates") +
  xlab("") +
  labs(caption = "error bars correspond to standard errors")

ggsave(linplot, filename = paste("vignettes/out/", modelname, "_linear_model_directions.pdf", sep = ""), dpi = 400,
       units = "cm", width = 29.7, height = 21)
```






# Select Variables
Select Variables for the models
- Ecosystem Functions : either EFdistance, EFturnover, EFnestedness or single functions
- LUI : either LUI and delta LUI or the individual components
- xaxis_gdm : is LUI or a component
```{r}
# print("user input required here!")
source('/run/user/1001/gvfs/smb-share:server=ipssmonstera.unibe.ch,share=planteco/DATA/BE_Synthesis/BetaDivMultifun/analysis_nonpublic.R', echo=F)

##  PSEUDO-AUTOMATIC RUNNING
# specify what is required here
# can be run from `analysis_nonpublic.R`:

## MODELS
funs <- "EFdistance"
# funs <- "EFabund_bray_gra"

## TURNOVER AND NESTEDNESS
# with several thresholds
# funs <- paste("EFturnover_", c(seq(0.1, 0.9, 0.1), "median"), sep = "")[1] # from 1 to 10
# funs <- paste("EFnestedness_", c(seq(0.1, 0.9, 0.1), "median"), sep = "")[1] # from 1 to 9

## SINGLE FUNCTIONS
# funs <- colnames(EFmaster)[11] # from 3 to 19

# LUI is one of the below
# lui <- c("LUI", "deltaLUI")
lui <- c("Gstd", "Mstd", "Fstd", "deltaGstd", "deltaMstd", "deltaFstd")

# xaxis_gdm <- "LUI"
xaxis_gdm <- "Fstd"
```

# Prepare for GDM
```{r}
lui <- lui[!lui %in% xaxis_gdm]
modelname <- paste("gdm", funs, xaxis_gdm, sep = "_")

include <- c("Var1", "Var2", funs)
EFmaster <- EFmaster[, ..include]

xLUI <- LUI[, c("Plotn", xaxis_gdm)]
LUI <- LUI[, c("Plotn", lui)]

# Group dissimilarity matrices (long format):
# combine functions, betadiversity and predictors
fordistpreds <- merge(predictors_soil, masterbeta, by = c("Var1", "Var2"))
fordistpreds <- merge(fordistpreds, EFmaster, by = c("Var1", "Var2"))
rm(predictors_soil, masterbeta); gc()
```

Calc dissimilarities from covariates which are not dissimilarities yet
```{r}
forpredData <- merge(predictors, LUI, by = "Plotn")
rownames(forpredData) <- forpredData$Plotn
forpredData$Plotn <- NULL

# calculate euclidean distance for all predictors except for geographic distances
foreuclid <- names(forpredData)[!names(forpredData) %in% c("Longitude_Dec_Plotcenter", "Latitude_Dec_Plotcenter")]
for(i in foreuclid){
  data <- as.matrix(vegan::vegdist(forpredData[, i, drop=F], method = "euclid"))
  data[!lower.tri(data)] <- NA
  data <- reshape2::melt(data, value.name=i)
  fordistpreds <- merge(fordistpreds, data, value.name = i, by = c("Var1", "Var2"))
}
# take out variables for which euclidean distance was calculated, such that only geographic distance stays
forpredData <- forpredData[, !names(forpredData) %in% foreuclid]

# calculate geographic distance
for(i in 1:length(rownames(fordistpreds))){
  new <- geosphere::distGeo(forpredData[fordistpreds[i, 1], c("Longitude_Dec_Plotcenter", "Latitude_Dec_Plotcenter")], forpredData[fordistpreds[i, 2], c("Longitude_Dec_Plotcenter", "Latitude_Dec_Plotcenter")])
  fordistpreds[i, "geo_dist"] <- new
}

# standardization of non-betadiversities to be between 0 and 1
# apply(fordistpreds, 2, range)
forstand <- c(foreuclid,"geo_dist")
fordistpreds[, names(fordistpreds) %in% forstand] <- apply(fordistpreds[, names(fordistpreds) %in% forstand], 2, scale01)

rm(foreuclid); rm(forstand); rm(i)
```

# add LUI values
add the LUI value selected by `xaxis_gdm` as geographic coordinate to the gdm data.
```{r}
setnames(xLUI, old = c("Plotn", xaxis_gdm), new = c("Var1", "s1.xCoord"))
fordistpreds <- merge(fordistpreds, xLUI, by = "Var1", all.x = T)
setnames(xLUI, old = c("Var1", "s1.xCoord"), new = c("Var2", "s2.xCoord"))
fordistpreds <- merge(fordistpreds, xLUI, by = "Var2", all.x = T)
```



# Check Correlation
```{r, eval = T}
# name : modelname "_corrplot_before_gdm.pdf"
m <- cor(fordistpreds[, -c(1:2, 36)])
pdf(paste("out/", modelname, "_corrplot_before_gdm.pdf", sep = ""), paper = "a4r")
corrplot::corrplot(m, type = "lower", addCoef.col = "black", method = "color", diag = F, tl.srt = 50, tl.col = "black", order = "hclust", tl.cex = 0.4, cl.cex = 0.3, number.cex = 0.3)
dev.off()
```
Variance inflation
```{r}
# generate model
mod <- paste(funs, " ~ " ,paste(colnames(fordistpreds)[!colnames(fordistpreds) %in% c(funs, "Var1", "Var2")], collapse = " + "))
m1 <- lm(formula = formula(mod), data = fordistpreds)
vif_output <- car::vif(m1)
vif_output[which(vif_output > 5)]
# vif_output[which(vif_output[, "GVIF"] > 5),]
capture.output(mod,
               vif_output[which(vif_output > 5)],
               file = paste("out/", modelname, "_vif_before_gdm.txt", sep = ""))
```
We will leave the inflated variables in the dataset, but perform a sensitivity analysis later. --> The inflated variables are not distinguishable, maybe the effect is partitioned among them.


# Prepare GDM Table
GDM requires a well-defined table. Below, the names of the columns and their content are listed:
- distance : distance between ecosystem functions
- weights : column containing all 1 (because we weigh all comparisons the same)
- s1.xCoord, s1.yCoord, s2.xCoord, s2.yCoord : 4 columns which will be ignored as I will set geo = F in the gdm() function. 
- s1.pred1, ..., s1.predn : here I fill in my predictor columns, (all have s1. at the beginning)
- s2.pred1, ..., s2.predn : here I fill in columns of zero to imitate I would not have given distance but two values.

```{r}
meltset <- data.table::as.data.table(fordistpreds)
# delete first 2 columns as not used any more
plotorder <- meltset[,.(Var1, Var2)] # backup for plots, in case I need it again
meltset[,c("Var1","Var2") := NULL]

# rearrange column order
colorder <- funs
colorder1 <- colnames(meltset)[!colnames(meltset) %in% colorder]
data.table::setcolorder(meltset, colorder)

# define the new colnames
names(meltset)[names(meltset) %in% funs] = "distance" # functions column is named "distance"
# all predictors are having s1. at the beginning
newnames <- paste("s1.", colorder1[!colorder1 %in% c("s1.xCoord", "s2.xCoord")], sep = "")
names(meltset)[!names(meltset) %in% c("distance", "s1.xCoord", "s2.xCoord")] <- newnames

# adding new columns at the right positions
newcols <- c("weights", "s1.yCoord", "s2.yCoord")
meltset[, (newcols) := 0]
meltset[, weights := 1]

# order in right position
colorder <- c("distance", newcols[1], "s1.xCoord", newcols[2], "s2.xCoord", newcols[3], newnames)
data.table::setcolorder(meltset, colorder)

# add empty s2. columns at the end
newcols2 <- gsub("1", "2", newnames)
meltset[, (newcols2) := 0]

# gdm wants meltset to be a data.frame
meltset <- as.data.frame(meltset)

# row names of meltset must be the plot combinations
rownames(meltset) <- paste(plotorder$Var1, plotorder$Var2, sep=".")

# formatsitepair has been used, but does not do anything to the data if runned like this
meltset <- gdm::formatsitepair(bioData=meltset, bioFormat = 4, predData=meltset) 
```

# Run GDM
The model name is automatically generated from `funs` and `lui`.
```{r}
outname <- paste("gdm", funs, xaxis_gdm, "output_summary.txt", sep = "_")
outnameRDS <- paste("gdm", funs, xaxis_gdm, "output.Rds", sep = "_")
gdm_output <- gdm::gdm(meltset, geo = T)
# summary(gdm_output)

# save input and output
saveRDS(meltset, file = paste("out/", paste("gdm", funs, xaxis_gdm, "input.Rds", sep = "_"), sep = ""))
saveRDS(gdm_output, paste("out/", outnameRDS, sep = ""))
capture.output(summary(gdm_output), file = paste("out/", outname, sep = ""))
```

go to cluster scripts and plot.