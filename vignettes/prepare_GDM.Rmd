---
title: "run GDM"
author: "Noelle Schenk"
date: "June 21, 2019"
output: html_document
---
note : packages used : gdm, car, geosphere, viridis and colrobrewer

# Cleaning
maybe this part can be moved to where it should have been done...
```{r}
colnames(predictors)[1] <- "Plotn"
# standardise EFdistance
new <- scale01(EFmaster$EFdistance)
EFmaster$EFdistance <- new
```


# Select Variables
Select Variables for the models

Ecosystem Functions : either EFdistance, EFturnover or EFnestedness
```{r}
funs <- "EFdistance" # to have a variable containing the currently used Ecosystem function
EFmaster <- EFmaster[, c("Var1", "Var2", "EFdistance")]
# EFmaster <- EFmaster[, c("Var1", "Var2", "EFturnover")]
# EFmaster <- EFmaster[, c("Var1", "Var2", "EFnestedness")]
```

LUI : either LUI and delta LUI or the individual components
```{r}
LUI <- LUI[, c("Plotn", "LUI", "deltaLUI")]
```

# Prepare for GDM

Group dissimilarity matrices (long format):
combine functions, betadiversity and predictors
```{r}
fordistpreds <- merge(predictors_soil, masterbeta, by = c("Var1", "Var2"))
fordistpreds <- merge(fordistpreds, EFmaster, by = c("Var1", "Var2"))
rm(predictors_soil, masterbeta); gc()
```

Calc dissimilarities from covariates which are not dissimilarities yet
```{r}
forpredData <- merge(predictors, LUI, by = "Plotn")
rownames(forpredData) <- forpredData$Plotn
forpredData$Plotn <- NULL

# calculate euclidean distance for all predictors except for geographic distances
foreuclid <- names(forpredData)[!names(forpredData) %in% c("Longitude_Dec_Plotcenter", "Latitude_Dec_Plotcenter")]
for(i in foreuclid){
  data <- as.matrix(vegan::vegdist(forpredData[, i, drop=F], method = "euclid"))
  data[!lower.tri(data)] <- NA
  data <- reshape2::melt(data, value.name=i)
  fordistpreds <- merge(fordistpreds, data, value.name = i, by = c("Var1", "Var2"))
}
# take out variables for which euclidean distance was calculated, such that only geographic distance stays
forpredData <- forpredData[, !names(forpredData) %in% foreuclid]

# calculate geographic distance
for(i in 1:length(rownames(fordistpreds))){
  new <- geosphere::distGeo(forpredData[fordistpreds[i, 1], ], forpredData[fordistpreds[i, 2], ])
  fordistpreds[i, "geo_dist"] <- new
}

# standardization of non-betadiversities to be between 0 and 1
# apply(fordistpreds, 2, range)
forstand <- c(foreuclid,"geo_dist")
fordistpreds[, names(fordistpreds) %in% forstand] <- apply(fordistpreds[, names(fordistpreds) %in% forstand], 2, scale01)
```

# Check Correlation
```{r}
m <- cor(fordistpreds[, -c(1:2)])
corrplot::corrplot(m, type = "lower", addCoef.col = "black", method = "color", diag = F, tl.srt = 50, tl.col = "black", order = "hclust", tl.cex = 0.4, cl.cex = 0.3, number.cex = 0.3)
```
Variance inflation
```{r}
# generate model
mod <- paste("EFdistance ~ " ,paste(colnames(fordistpreds)[!colnames(fordistpreds) %in% c("EFdistance", "Var1", "Var2")], collapse = " + "))
m1 <- lm(formula = formula(mod), data = fordistpreds)
vif_output <- car::vif(m1)
vif_output[vif_output > 5]
#TODO : I have variable inflation of over 5 in 4 variables - most probably between nestedness and turnover components!
# suggest : keep that in mind - for soilfungi decomposers, pathotroph, ... we can not really tell if turnover or nestedness...
```

# Prepare GDM Table
GDM requires a well-defined table. Below, the names of the columns and their content are listed:
- distance : distance between ecosystem functions
- weights : column containing all 1 (because we weigh all comparisons the same)
- s1.xCoord, s1.yCoord, s2.xCoord, s2.yCoord : 4 columns which will be ignored as I will set geo = F in the gdm() function. 
- s1.pred1, ..., s1.predn : here I fill in my predictor columns, (all have s1. at the beginning)
- s2.pred1, ..., s2.predn : here I fill in columns of zero to imitate I would not have given distance but two values.

```{r}
meltset <- data.table::as.data.table(fordistpreds)
# delete first 2 columns as not used any more
plotorder <- meltset[,.(Var1, Var2)] # backup for plots, in case I need it again
meltset[,c("Var1","Var2") := NULL]

# rearrange column order
colorder <- funs
colorder1 <- colnames(meltset)[!colnames(meltset) %in% colorder]
data.table::setcolorder(meltset, colorder)

# define the new colnames
names(meltset)[names(meltset) %in% funs] = "distance" # functions column is named "distance"
# all predictors are having s1. at the beginning
newnames <- paste("s1.", colorder1, sep = "")
names(meltset)[-1] <- newnames

# adding new columns at the right positions
newcols <- c("weights", "s1.xCoord", "s1.yCoord", "s2.xCoord", "s2.yCoord")
meltset[, (newcols) := 0]
meltset[, weights := 1]

# order in right position
colorder <- c("distance", newcols, newnames)
data.table::setcolorder(meltset, colorder)

# add empty s2. columns at the end
newcols2 <- gsub("1", "2", newnames)
meltset[, (newcols2) := 0]

# gdm wants meltset to be a data.frame
meltset <- as.data.frame(meltset)

# row names of meltset must be the plot combinations
rownames(meltset) <- paste(plotorder$Var1, plotorder$Var2, sep=".")
```

# Run GDM
```{r}
gdm_efdist <- gdm(meltset, geo = F, splines = NULL, knots = NULL)
capture.output(summary(gdm_efdist), file = "gdm_efdist_output.txt")
```

# Plot GDM
```{r}
exSplines <- gdm::isplineExtract(gdm_efdist)

# to plot each spline in a separate plot
plot(gdm_efdist, plot.layout = c(3, 2), plot.color = "grey",main="GDM",sub= paste(vars_in_model, collapse=', '))
```

# TODO 
HERE .

- run all models
- run bootstrapping
- plot all models
- solve open TODOS (e.g. variance inflation)


```{r}


#############################
#  PLOTTING I - SPLINES
#
vars_in_model <- c(funs,typeofbeta,which_beta_detail)
# to plot each spline in a separate plot
# plot(gdm_actual, plot.layout = c(3, 2), plot.color = "grey",main="GDM",sub= paste(vars_in_model, collapse=', '))

# produce a "normal" plot ---------
groesse <- 0.5 # size of text in plot
pdf('../test.pdf',paper='a4r')
par(xpd = T, mar = par()$mar + c(0,0,0,6))
plot(exSplines[[1]][,1], exSplines[[2]][,1], type="l",
     lwd=2, xlab="jtest", ylab="Partial Ecological Distance",ylim=c(0,0.65),main="GDM",sub= paste(vars_in_model, collapse=', '),
     cex=groesse, cex.axis= groesse, cex.lab= groesse, cex.sub=groesse*1.5)
for(i in 1:ncol(exSplines[[1]])){
  lines(exSplines[[1]][,i], exSplines[[2]][,i], col=colr[i],lwd=2,lty=ltyp[i])
}
legend(1.05,0.675,legend_names, lty=ltyp,lwd=c(1.5,1.5),col=colr[1:ncol(exSplines[[1]])],cex = 0.5) 
par(mar=c(5, 4, 4, 2) + 0.1)
dev.off()

#############################
#  ESTIMATING P - VALUES
#
# takes too long on my computer yet. but I can change, so it doesn't do aic and only looks at the full model - much faster! todo
varimp_output <- gdm.varImp(meltset, geo=F, parallel=T, nPerm =1) #, fullModelOnly=T)

#############################
#  SAVE PRODUCED DATA
#
# save current gdm_actual so I can get back to it
namegdm <- paste(funs, typeofbeta, paste(which_beta_detail, collapse="_"), sep="_")
assign(namegdm, gdm_actual)
namegdm <- paste(namegdm, "VARIMP_OUTPUT", sep="_")
assign(namegdm, varimp_output)
rm(namegdm)

#############################
#  Plotting P - VALUES
#
legend_names <- gsub("_abund_","_ab_", legend_names)
pvals <- mod1_pvals[[3]][,1]
legend_names[which(as.vector(pvals)== 0)] <- paste(legend_names[which(as.vector(pvals)== 0)],'*')

groesse <- 0.5 # size of text in plot
pdf('../test.pdf',paper='a4r')
par(xpd = T, mar = par()$mar + c(0,0,0,6))
plot(exSplines[[1]][,1], exSplines[[2]][,1], type="l",
     lwd=2, xlab="predictors", ylab="Partial Ecological Distance",ylim=c(0,0.65),main="GDM",
     sub= "subtitle",
     cex=groesse, cex.axis= groesse, cex.lab= groesse, cex.sub=groesse*1.5)
for(i in 1:ncol(exSplines[[1]])){
  lines(exSplines[[1]][,i], exSplines[[2]][,i], col=colr[i],lwd=2,lty=ltyp[i])
}
legend(1.05,0.675,legend_names, lty=ltyp,lwd=c(1.5,1.5),col=colr[1:ncol(exSplines[[1]])],cex = 0.5) 
par(mar=c(5, 4, 4, 2) + 0.1)
dev.off()
```

