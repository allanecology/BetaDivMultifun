---
title: "prepare_covariates"
author: "noelleschenk"
date: "April 16, 2019"
output: html_document
---

Here, covariates are prepared. At the moment : only soil. Will add plot isolation & Co

# Soil
## Cleaning soil covariates
```{r}
#USER : change paths and uncomment wanted
# main_glsoil <- fread("../data/Grassland EP soil descriptors.txt")
# small_glsoil <- fread("../data/BE env covariates.txt") # from here, I only take soil type and TWI
small_glsoil <- small_glsoil[, c("Plot", "Soil.type", "TWI")]
# take out empty row at the end
small_glsoil <- small_glsoil[Plot != "",]
# names_gl <- fread("../data/20826_plotNames.txt") # read a file where the different plotnames are documented
```
clean and merge covariate dataset
```{r}
names_gl <- names_gl[Landuse == "G",.(EP_PlotID,PlotID)]
data.table::setnames(names_gl, old="EP_PlotID", new="Plot")
# add useful plot IDs
names_gl <- merge(names_gl, raw_grlfuns[, c("Plot", "Plotn")], by="Plot", all=T)
# merge main_glsoil with names_gl to get the wanted names
data.table::setnames(main_glsoil, "plotid","PlotID")
main_glsoil <- merge(main_glsoil, names_gl, by="PlotID", all=T)
main_glsoil[Plotn %in% c("AEG29", "AEG10"),] # there are two duplicated rows without data
main_glsoil <- main_glsoil[!PlotID %in% c("A32886", "A8338"),]

# merge the 2 datasets
data.table::setnames(small_glsoil, "Plot", "Plotn")
glsoil <- merge(main_glsoil, small_glsoil, by="Plotn", all=T)
rm(main_glsoil) ; rm(names_gl) ; rm(small_glsoil)

# remove unwanted columns
glsoil[, c("PlotID", "Exploratory", "Plot") := NULL]
```


## Plot selection
```{r, eval=F}
#TODO : 
# take out the plots that I exclude from analysis
glsoil <- glsoil[!Plot %in% plot_NAset ,]
rm(plot_NAset)
```


## Create binary data from Soil.type
Because PCA can not fit categorical data which have > 2 categories. 

This probably adds some overlaping information with the amount of sand, clay etc. But this does not matter, as selecting the PCA components will take this extra information out again.

TODO : *This is a "human" classification, not a "pure physical". Based on which informations? Do we add some "false" information with that, which is then left in the data as only the overlapping information is "removed" in the PCA?*

```{r}
stype <- glsoil[, .(Plotn, Soil.type)]
stype[, Rendzina := ifelse(Soil.type == "Rendzina", 1, 0)]
stype[, Braunerde := ifelse(Soil.type == "Braunerde", 1, 0)]
stype[, Pelosol := ifelse(Soil.type == "Pelosol", 1, 0)]
stype[, Pseudogley := ifelse(Soil.type == "Pseudogley", 1, 0)]
stype[, Erdniedermoor := ifelse(Soil.type == "Erdniedermoor", 1, 0)]
stype[, Gley := ifelse(Soil.type == "Gley", 1, 0)]
stype[, Mulmniedermoor := ifelse(Soil.type == "Mulmniedermoor", 1, 0)]
stype[, Parabraunerde := ifelse(Soil.type == "Parabraunerde", 1, 0)]
stype[, Fahlerde := ifelse(Soil.type == "Fahlerde", 1, 0)]
stype[, Soil.type := NULL]
# merge to glsoil
glsoil <- merge(glsoil, stype, by="Plotn", all=T)
# store unscaled dataset for functions imputation
glsoil_unscaled <- data.table::copy(glsoil)
```


## Normalisation
scale the columns which are neither binary nor factors. Scaled by centering around 0 (substracting the mean) and dividing by standard deviation.
```{r}
# create scaling vector T/F of which columns to scale in pcr
scalecols <- c("Clay", "Fine.Silt", "Medium.Silt", "Coarse.Silt", "Fine.Sand", "Medium.Sand", "Coarse.Sand", "pH", "Soil.depth", "TWI")
glsoil[, (scalecols) := lapply(.SD, function(x) scale(x, center = T)), .SDcols = scalecols]
```


Could be done within PCA computation with parameter `scale = TRUE`.
```{r}
mysubset <- names(glsoil)[!names(glsoil) %in% c("Plotn", "Soil.type")]
```
*note* : The binary categoric columns are not affected by this.
```{r}
plot(glsoil$Rendzina)
points(glsoil$Braunerde)
points(glsoil$Pelosol)
points(glsoil$Pseudogley)
points(glsoil$Erdniedermoor)
points(glsoil$Gley)
points(glsoil$Mulmniedermoor)
points(glsoil$Parabraunerde)
points(glsoil$Fahlerde)
```


## soil PCA
```{r}
# Plot information is taken as rownames of a data.frame (instead of data.table).
pc_glsoil <- as.data.frame(glsoil[,-1])
rownames(pc_glsoil) <- glsoil$Plotn
rm(glsoil)

# run the pca
pca_from_glsoil <- prcomp(pc_glsoil[, !(names(pc_glsoil) %in% "Soil.type")], scale = F)
plot(pca_from_glsoil) 
```
The first 4 axis would make sense if the dimensionality would need to be reduced a lot. 

However, here it is not that much about reducing dimensionality, but taking out unnecessary variables. Therefore, Taking PC1 to 17 is suitable, as PC18 and 19 do not add any more information.
```{r}
# first 4 axis would make sense
summary(pca_from_glsoil)
```

### PCA insights
```{r, eval=F}
# color by soil type
ggplot2::autoplot(pca_from_glsoil, data = pc_glsoil, colour = 'Soil.type')
ggplot2::autoplot(pca_from_glsoil, data = pc_glsoil, colour = 'Soil.depth')

ggplot2::autoplot(pca_from_glsoil, data = pc_glsoil, loadings = TRUE, loadings.colour = 'darkgray', loadings.label = TRUE, loadings.label.size = 2)
```

```{r, eval=F}
ggplot2::autoplot(pca_from_glsoil, x=3, y=4, data=pc_glsoil, colour="Soil.type")
ggplot2::autoplot(pca_from_glsoil, x=3, y=4, data=pc_glsoil, colour="pH")
```

### Component selection
Components 1 to 17 (as argued above).
```{r}
pca_from_glsoil <- pca_from_glsoil$x[, 1:17]
```

## Computation of Dissimilarity Matrices
With euclidian distance : `edis_glsoil`
With betadiversity : `beta_glsoil`.

*note* beta.pair.abund can not handle negative abundance values. Therefore, data needs to be centered around 0 instead of centered around 0. However, max is `r max(pca_from_glsoil)` and min is `r min(pca_from_glsoil)`. Would need an "abundance" value which makes sense.

```{r}
# welect plot set? #NEW!
# select from matrix
pca_from_glsoil <- pca_from_glsoil[which(rownames(pca_from_glsoil) %in% plotNAset), ]
pca_from_glsoil <- pca_from_glsoil[which(rownames(pca_from_glsoil) != "HEG31"), ]

# compute dissimilarities for all principal components I got (10) (euclidian distance)
edis_glsoil <- vegan::vegdist(pca_from_glsoil, method = "euclid")

#TODO : if I want to calc beta, I need to find good solution for handling negative values.
# beta_glsoil <- betapart::beta.pair.abund(pca_from_glsoil)
```

## Cleaning for GDM
```{r}
# prepare for gdm (the desired format)
edis_glsoil <- as.matrix(edis_glsoil)
# save as RDS
# saveRDS(edis_glsoil, file="soil_covariate.RDS")

# select Plots for the analysis
# edis_glsoil <- cbind("Plot" = seq(1,130), edis_glsoil)

# CLEANING away all I don't need to run gdm
rm(pca_from_glsoil); rm(pc_glsoil) ; rm(mysubset); rm(stype)
# glsoil_unscaled is used for gap-filling and therefore not deleted here.
```


# Plot isolation

#TODO add more covariates