---
title: "Functions Processing for BetaDivMultifun"
output:
  pdf_document: default
  html_notebook: default
---
In this script : gapfilling

TODO : proofreading, cleaning, ...

# Data
The dataset used for gap filling is larger than the dataset used for the analysis. More variables enhance the performance of gapfilling.
```{r}
#USER : insert path to grassland function file and read in as grlfuns (uncomment line below)
# raw_grlfuns <- data.table::fread("<pathto_grl_functions.csv>", header=T)
#TODO add bexis link?
```
Grassland functions data used for gapfilling is stored in `raw_grlfuns`, selected variables according to info data. `raw_grlfuns` is loaded by `analysis_nonpublic.R`.

It also relies on a soil information dataset, which is prepared by `prepare_covariates.Rmd`.

# Gap filling
A Gap-filling of the functions dataset is performed, because many values are missing (NA). To enhance the predictions of the gapfilling, soil data is included. This introduces a bias, but reduces the imputation error. 

Two variables are produced, impdat which contains the gapfilled dataset which will be used in further analysis as well as imp_err, which contains the imputation error automatically estimated by missForest. The imputed dataset is stored as rds file.

## Data preparation
Soil predictor data and Region is included to improve Gap filling. uncomment if not wanted!
```{r}
#USER : uncomment this block if soil information should not be included.
remove <- unique(glsoil_unscaled$Soil.type)
glsoil_unscaled[, (remove) := NULL]
glsoil_unscaled[, Soil.type := as.factor(Soil.type)] # soil type as factor
rm(remove)
```

```{r}
befun <- merge(raw_grlfuns, glsoil_unscaled, by="Plotn")
befun[, Explo := as.factor(Explo)] # Region as a factor
```

chosing the plot set
```{r}
befun <- befun[Plotn %in% plotNAset]
```


cleaning out variables with too many missing values
```{r}
visdat::vis_miss(befun, sort_miss = T)
```
Values with over 21% missing data are excluded: mAMF hyphae, Parasitoid traps, Aggregation and pathogen infection.
```{r}
#USER : set treshold for missing values
treshold <- 0.21
t <- apply(befun, 2, function(x) sum(is.na(x)))
exclude <- names(which(t > 150 * treshold))
befun <- befun[, !colnames(befun) %in% exclude, with=F]
rm(t); rm(exclude); rm(treshold)
```

If the missing plot from 16S, amoA_AOA.2016 & Co is taken out, 5 more functions can be included in the functions set.
```{r}
# befun[is.na(`16S_NB`), Plotn]
# befun[is.na(amoA_AOA.2016), Plotn]
# befun[is.na(amoA_AOB.2016), Plotn]
# The missing plot is "HEG31"
befun <- befun[Plotn != "HEG31"]
```


## Check Correlations
Of the non-factor columns only
```{r}
corrbefun <- befun[, !colnames(befun) %in% c("Explo", "Soil.type", "Plotn", "Plot"), with=F]
M <- cor(corrbefun, use="pairwise.complete.obs")

# raw_grlfun_corrplot1
corrplot::corrplot(M,type="lower",addCoef.col = "black",method="color",diag=F, tl.srt=1, tl.col="black", mar=c(0,0,0,0), number.cex=0.6)

# raw_grlfun_corrplot2
corrplot::corrplot(M, type = "upper", tl.col="black", tl.srt=40, diag = F)

# only show high correlations
tres <- 0.7
M[which(M < tres & M > -tres)] <- 0
corrplot::corrplot(M, type = "upper", tl.col="black", tl.srt=40, diag = F)
```
Network
```{r}
# show network - is there a variable "alone"? bzw. isolated?
network <- igraph::graph_from_adjacency_matrix(M, weighted=T, mode="undirected", diag=F)
plot(network)
```
There is no variable which is not connected with at least one line to another variable. Lines represent correlations > threshold.
```{r}
rm(M); rm(network)
```


## Log transformation
before changing values, store the original dataset
```{r}
befunbackup <- data.table::copy(befun)
```
remove negative values, remember to add again after imputation!

find negative values
```{r}
par(mar = c(10, 1, 3, 1))
boxplot(corrbefun, las=2)
# minimum of the numeric columns
negative <- colnames(corrbefun)[which(corrbefun[, lapply(.SD, function(x) min(x, na.rm=T))] < 0)]
```
remove negative values - shift whole vector up.
```{r}
# DEA
mindea <- min(befun$DEA, na.rm=T)
befun$DEA <- befun$DEA + abs(mindea)
# NO3.2014
minno <- min(befun$NO3.2014, na.rm=T)
befun$NO3.2014 <- befun$NO3.2014 + abs(minno)
# dung.decomposition
mindung <- min(befun$dung.decomposition, na.rm=T)
befun$dung.decomposition <- befun$dung.decomposition + abs(mindung)
rm(negative)
```
Log transformation of the numeric columns. The natural logartithm of values smaller than 1 is negative. Tehrefore, all values are shifted by 1 again to avoid any negative values in the log transformed dataset.
```{r}
numcols <- colnames(befun)[!colnames(befun) %in% c("Explo", "Soil.type", "Plotn", "Plot")]
befun[, (numcols) := lapply(.SD, as.numeric), .SDcols = numcols]
# log transform the values + 1, later shift them back.
befun[, (numcols) := lapply(.SD, function(x) log(x+1)), .SDcols = numcols]
# record NA value positions for visualistation
naloc <- is.na(befun)
```

## Imputation

### Imputation test
Find and evaluate the imputation error of a single iteration and optimise the process for 50x imputation. (The code for the imputation loop is copied, just one imputation done.)
```{r}
# based on one-time imputation, take out : "amoA_AOA.2016" ,"amoA_AOB.2016",  "nxrA_NS", "16S_NB"
#TODO : change back to plot and plotn only.
numcols <- numcols[which(!numcols %in% c("Plotn", "Plot"))]
dataset <- befun[, !colnames(befun) %in% c("Plotn", "Plot"), with=F]

# run one imputation with missforest.
require(data.table)
returnobj <- perform_missforest_imputations(dataset = dataset, numcols = numcols, im=1)
imperr <- returnobj$errors
impvals <- returnobj$values
rm(returnobj)
```
Visualise imputation results.
```{r}
barplot(height=imperr[[1]][,errors], names.arg = imperr[[1]][, columns])
library(cowplot)
p<-ggplot2::ggplot(data=imperr[[1]], ggplot2::aes(x=columns, y=errors)) +
  ggplot2::geom_bar(stat="identity") +
  theme(axis.text.x=element_text(color = "black", size=5, angle=30, vjust=.8, hjust=0.8)) +
  geom_hline(yintercept=0.25, linetype="dashed", color = "gray")
p
```
Need to take out Parasitoid traps, Potential nitrification (2011 and 2014) and total pollinators.


### Imputation

The imputation is repeated 50 times, and the mean of the imputed values is taken. 
```{r imputation, results="hide", eval=F}
# 50 imputations
impvals <- list()
imperr <- list()
# based on one-time imputation, take out : "amoA_AOA.2016" ,"amoA_AOB.2016",  "nxrA_NS", "16S_NB"
#TODO : change back to plot and plotn only.
numcols <- numcols[which(!numcols %in% c("Plotn", "Plot"))]
dataset <- befun[, !colnames(befun) %in% c("Plotn", "Plot"), with=F]

for(i in 1:50){
  print(i)
  current <- missForest::missForest(dataset, variablewise = T)
  imperr[[i]] <- data.table::data.table("columns" = colnames(dataset), "errors" =current$OOBerror)
  current <- as.data.table(current$ximp)
  # re-transform the numeric variables
  current[, (numcols) := lapply(.SD, function(x) (exp(x)-1)), .SDcols = numcols]
  # re-transform the negative values
  current$DEA <- current$DEA - abs(mindea)
  current$NO3.2014 <- current$NO3.2014 - abs(minno)
  current$dung.decomposition <- current$dung.decomposition - abs(mindung)
  # add back the "Plotn" column which was taken out for imputation
  current[, Plotn := befun$Plotn]
  # convert imputed data.table to matrix, as more handy for imputed values handling
  impvals[[i]] <- current
}
rm(current); rm(i); rm(mindea); rm(minno); rm(mindung)
# USER : may change filename
saveRDS(impvals, file="raw_imputed_function_values_complete.rds")
saveRDS(imperr, file = "raw_imputed_function_errors_complete.rds")
# impvals <- readRDS("raw_imputed_function_values_complete.rds")
# imperr <- readRDS("raw_imputed_function_errors_complete.rds")
```

Check imputation error
```{r}
imperr <- do.call(rbind, imperr)
mimperr <- data.table::as.data.table(aggregate(errors ~ columns, imperr, mean))
mean(mimperr[,errors])

barplot(height=mimperr[,errors], names.arg = mimperr[, columns])
library(cowplot)
p<-ggplot2::ggplot(data=mimperr, ggplot2::aes(x=columns, y=errors)) +
  ggplot2::geom_bar(stat="identity") +
  theme(axis.text.x=element_text(color = "black", size=5, angle=30, vjust=.8, hjust=0.8)) +
  geom_hline(yintercept=0.25, linetype="dashed", color = "gray")
p
```
The imputation error range is extremely small. The possible range is between 0 and 1, however here the range is between 0.143 and 0.151.

Get together imputed dataset from 50 imputations.
```{r}
# backup <- impvals
X <- do.call(rbind, impvals)
X <- data.table::as.data.table(X)
X[, (numcols) := lapply(.SD, as.numeric), .SDcols=numcols]
# backup2 <- data.table::copy(X)

# two ways of aggregating the 50 imputed values together
# Y <- aggregate(X[, ..numcols], list(Plotn=X$Plotn), mean)
Y <- X[, lapply(.SD, mean, na.rm=T), .SDcols=numcols, by=Plotn]
Y <- data.table::data.table(Y)
```

Compare imputed values with real values. Creates the pdf `imputed_values.pdf`
```{r, eval=F}
pdf("imputed_values.pdf", paper="a4r")
par(mfrow = c(2,7))
for(i in 1:length(numcols)){
  x <- rep(1, 127)
  colname <- numcols[i]
  # length of the imputed value vector
  rowlocations <- naloc[, colname]
  y <- Y[rowlocations, get(colname)]
  plot(x, befunbackup[, get(colname)], xlab="", ylab="range of values", main=colname, sub=paste(length(y), "NAs"))
  x <- x[0:length(y)]
  points(x, y, col="red",pch=19)
}
dev.off()
```

Take out soil variables again and store imputed grassland function dataset.
```{r}
# take out colnames of glsoil_unscaled, except "Plotn"
Y[, (colnames(glsoil_unscaled)[!colnames(glsoil_unscaled) %in% c("Plotn", "Soil.type")]) := NULL]
saveRDS(Y, file="imputed_function_values.rds")
# clean a bit
imputed_grlfuns <- data.table::copy(Y)
```

The multifunctionalities of imputed functions are calculated in another script. Current name "calc_multifun_from_imputed".
