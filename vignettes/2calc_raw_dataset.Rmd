---
title: "assembled dataset construction"
author: "noelle"
date: "December 5, 2018"
output: html_document
---

# Biomass 2009
## take as it is
Because ranges are comparable to other years.
```{r, eval=F}
Biomass2009 <- list_raw_functions$Biomass2009
# how different are 2009 values of other years?
plot(rep(2008, 150), raw_functions$Biomass2008, ylim= c(0, 2000), xlim=c(2007,2018))

points(rep(2010, 150), raw_functions$Biomass2010)
points(rep(2011, 150), raw_functions$Biomass2011)
points(rep(2012, 150), raw_functions$Biomass2012)
points(rep(2013, 150), raw_functions$Biomass2013)
points(rep(2014, 150), raw_functions$Biomass2014)
points(rep(2015, 150), raw_functions$Biomass2015)
points(rep(2016, 150), raw_functions$Biomass2016)
points(rep(2017, 150), raw_functions$Biomass2017)

points(rep(2009, 149), Biomass2009[Treatment == "K2", Biomass2009], col="green")
```

```{r}
Biomass2009 <- list_raw_functions$Biomass2009
Biomass2009 <- aggregate(Biomass2009~Plot, Biomass2009, mean)
raw_functions <- merge(raw_functions, Biomass2009, by = "Plot", all = T) ; rm(Biomass2009)
list_raw_functions["Biomass2009"] <- NULL
```


## linear model day vs. biomass

$$Biomass = -161.959 + (3.131 * day)$$
- Take + 30 days of Biomass production for all plots.
- how much biomass is produced in 30 days?
- add this value to all data points
```{r, eval=F}
Biomass2009 <- list_raw_functions$Biomass2009
# construct linear model
# Biomass calculation as a function of day
# Biomass = -161.959 + (3.131 * day)
mod <- lm(Biomass2009 ~ Day_of_year, data=Biomass2009)
# summary(mod)


# newvalues
impBiomass2009I <- data.table::copy(Biomass2009)
impBiomass2009I[,"Day_of_year" := Day_of_year + 30]
data.table::setnames(impBiomass2009I, old="Biomass2009", new="oldBiomass2009")
impBiomass2009I[, "Biomass2009" := predict(mod, impBiomass2009I)]

# plot result
par(mfrow=c(1,2))
plot((impBiomass2009I$Day_of_year - 30)/30, impBiomass2009I$oldBiomass2009, col="darkgreen", xlim = c(4,6.6))
points((impBiomass2009I$Day_of_year)/30, impBiomass2009I$Biomass2009, col="darkred")


# variant 2
# to keep the variation
# calculate how much difference in Biomass are 30 days
doy <- data.table("Day_of_year" = c(0, 30))
doy <- predict(mod, doy)
increase <- doy[2] - doy[1]

# newvalues
impBiomass2009 <- data.table::copy(Biomass2009)
impBiomass2009[,"Day_of_year" := Day_of_year + 30]
data.table::setnames(impBiomass2009, old="Biomass2009", new="oldBiomass2009")
impBiomass2009[, "Biomass2009" := oldBiomass2009 + increase]

plot((impBiomass2009$Day_of_year - 30)/30, impBiomass2009$oldBiomass2009, col="darkgreen", xlim = c(4,6.6))
points((impBiomass2009$Day_of_year)/30, impBiomass2009$Biomass2009, col="darkred")

# criticism on imputation with linear model : it's very easy, maybe linear is not 
# the best way
# it's expected to depend on LUI too - take LUI into account?
# we will in the end anyways take the mean of biomasses
# --> is it necessary to have the same months?

rm(impBiomass2009); rm(impBiomass2009I); rm(mod); rm(increase); rm(doy)
```



# Root biomass
rb = fine root + coarse root biomass
```{r}
Root.biomass <- list_raw_functions$Root.biomass
Root.biomass[, "Root.biomass" := rowSums(.SD,na.rm=T), .SDcols=c("Fine_Roots_Biomass", "Coarse_Roots_Biomass")]
Root.biomass <- Root.biomass[, c("Plot", "Root.biomass")]
raw_functions <- merge(raw_functions, Root.biomass, by="Plot", all=T); rm(Root.biomass)
list_raw_functions["Root.biomass"] <- NULL
```

# Groundwater recharge
```{r}
Gtot <- list_raw_functions$Groundwater.recharge
raw_functions[, Groundwater.recharge := rowMeans(Gtot[,c(paste("Groundwater.recharge", seq(2010,2016), sep=""))])]
rm(Gtot)
list_raw_functions["Groundwater.recharge"] <- NULL
```


# forage quality
RFV : Relative Feed Value
RFQ : Relative Forage Quality
ADL : acid detergent lignin, Lignin
ADF : Acid Detergent Fibre, Säure-Detergenz-Faser, ein Teil der Gerüstsubstanzen von Futtermitteln
NDF : Neutral Detergent Fibre, Neutral-Detergenz-Faser, fasrige Anteile von Futtermitteln 

according to forage quality estimation based on alfalfa (medicago sativa) values. [source](https://openprairie.sdstate.edu/cgi/viewcontent.cgi?referer=https://scholar.google.ch/&httpsredir=1&article=1351&context=extension_extra)

[% concentration in aboveground grassland plant community biomass without litter]

```{r, eval=F}
forage.quality <- list_raw_functions$forage.quality

# 1. calc fq for each plot
forage.quality[, Crude.protein := 6.25*N]
forage.quality[, DDM := 88.9-(0.779* ADF)]
forage.quality[, DMI := 120/NDF]
forage.quality[, RFV := (DDM*DMI)/1.29]
forage.quality[, forage.quality := apply(scale(forage.quality[,c("RFV", "Crude.protein")]), 1, mean)]
# mean of years
forage.quality <- aggregate(forage.quality~Plot_name, forage.quality, mean)
forage.quality <- data.table::data.table(forage.quality)
data.table::setnames(forage.quality, old="Plot_name", new="Plot")

raw_functions <- merge(raw_functions, forage.quality, by="Plot", all=T)


# ohne biomasse - es geht um qualität, oder? "normalisation" der Jahre mit
# biomasse macht keinen sinn, da wir sowieso mit konzentrationen arbeiten...
# oder?


# forage.quality <- list_raw_functions[["forage.quality"]]
# # calculating the columns needed for forage quality calc
# forage.quality[, Crude.protein := 6.25*N]
# forage.quality[, DDM := 88.9-(0.779* ADF)]
# forage.quality[, DMI := 120/NDF]
# forage.quality[, RFV := (DDM*DMI)/1.29]
# forage.quality[, forage.quality := apply(scale(forage.quality[,c("RFV", "Crude.protein")]), 1, mean)]
# 
# # take apart the years and add separately to raw_functions
# forage.quality <- forage.quality[,c("Plot", "year", "forage.quality")]
# 
# for(i in unique(forage.quality$year)){
#   newname <- paste("forage.quality", i, sep="")
#   fi <- forage.quality[year == i]
#   data.table::setnames(fi, old="forage.quality", new=newname)
#   raw_functions <- merge(raw_functions, fi[,!"year"], by="Plot", all=T)
# }
```
See in compare_raw_function_to_synthesis for yearly calculation!

# Nshoot and Pshoot
same dataset like forage.quality

first convert soil P and microbial P to stocks rather than concentrations; concentrations are mg/kg, convert to g/g
```{r}
nutrients <- list_raw_functions$nutrients

# multiply with biomass!
# nutrients <- list_raw_functions$nutrients
# d09 <- merge(Biomass2009, nutrients, by="Plot", all=T)
# d09[, Nshoot.2009 := Biomass2009 * (Nshoot2009percent / 100)]
# bal <- merge(d09, synthesis[,c("Plot", "Nshoot.2009")])
# # maximum deviation of 6
# max(bal$Nshoot.2009.x - bal$Nshoot.2009.y, na.rm=T)
# # the larger the total values, the larger the deviation. Could be acceptable?
# plot(bal$Nshoot.2009.x, bal$Nshoot.2009.x - bal$Nshoot.2009.y)

# 2009
assemblednutrients <- merge(raw_functions[,c("Plot", "Biomass2009")], nutrients, by="Plot", all=T) 
assemblednutrients[, Nshoot.2009 := Biomass2009 * (Nshoot2009percent / 100)]
assemblednutrients[, Pshoot.2009 := Biomass2009 * (Pshoot2010percent / 100)]
# add to raw_functions
raw_functions <- merge(raw_functions, assemblednutrients[,c("Plot", "Nshoot.2009", "Pshoot.2009")], by="Plot", all=T)

# 2010

assemblednutrients <- merge(raw_functions[,c("Plot", "Biomass2010")], nutrients, by="Plot", all=T)
assemblednutrients[, Nshoot.2010 := Biomass2010 * (Nshoot2010percent / 100)]
assemblednutrients[, Pshoot.2010 := Biomass2010 * (Pshoot2010percent / 100)]
# add to raw_functions
raw_functions <- merge(raw_functions, assemblednutrients[,c("Plot", "Nshoot.2010", "Pshoot.2010")], by="Plot", all=T)

# 2011
assemblednutrients <- merge(raw_functions[,c("Plot", "Biomass2011")], nutrients, by="Plot", all=T)
assemblednutrients[, Nshoot.2011 := Biomass2011 * (Nshoot2011percent / 100)]
assemblednutrients[, Pshoot.2011 := Biomass2011 * (Pshoot2011percent / 100)]
# add to raw_functions
raw_functions <- merge(raw_functions, assemblednutrients[,c("Plot", "Nshoot.2011", "Pshoot.2011")], by="Plot")

# 2012
assemblednutrients <- merge(raw_functions[,c("Plot", "Biomass2012")], nutrients, by="Plot", all=T)
assemblednutrients[, Nshoot.2012 := Biomass2012 * (Nshoot2012percent / 100)]
assemblednutrients[, Pshoot.2012 := Biomass2012 * (Pshoot2012percent / 100)]
raw_functions <- merge(raw_functions, assemblednutrients[,c("Plot", "Nshoot.2012", "Pshoot.2012")], by = "Plot", all = T)

# 2013
assemblednutrients <- merge(raw_functions[,c("Plot", "Biomass2013")], nutrients, by="Plot", all=T)
assemblednutrients[, Nshoot.2013 := Biomass2013 * (Nshoot2013percent / 100)]
assemblednutrients[, Pshoot.2013 := Biomass2013 * (Pshoot2013percent / 100)]
raw_functions <- merge(raw_functions, assemblednutrients[,c("Plot", "Nshoot.2013", "Pshoot.2013")], by = "Plot", all = T) ; rm(assemblednutrients); rm(nutrients)

list_raw_functions["nutrients"] <- NULL
```


# Herbivory
## 2013
invertebrate herbivory in 146 managed temperate grasslands. Year: 2013

increased land-use - less invertebrates - less herbivory

Visually estimation of herbivory by eye using templates and measurement of leaf area left after feeding of the herbivores using LI-COR area meter

2 samples per plot in 145 cases, 1 sample for :  "AEG6"  "HEG16" "HEG43" "SEG19" "SEG33" and 3 samples for "SEG45". 2 Columns are included in the raw_functions dataset, 1 for each sample.

SEG45 : The mean of all 3 samples was already taken and stored as sample2. Taking the mean of samples2 first and then with sample1 would lead to different results than in the synthesis dataset.

note : used measure is very conservative. percent herbivory is on the whole plot, on both grasses and herbs.
```{r}
Herbivory.2013 <- list_raw_functions$Herbivory.2013

Herbivory.2013 <- aggregate(PercHerbivory~EP_Plotid, Herbivory.2013, mean)
data.table::setnames(Herbivory.2013, old=c("EP_Plotid", "PercHerbivory"), new=c("Plot", "herbivory.2013"))
raw_functions <- merge(raw_functions, Herbivory.2013, by="Plot", all.x=T) ; rm(Herbivory.2013)
list_raw_functions["Herbivory.2013"] <- NULL
```


# Litter.decomposition
litter bag approach, Mass loss in the litter bags, after two months, and four months. 1.5g of dry plant material. January 2013 put 10 bags each, 2 months later retrieval of 5 bags, 2 more months : retrieval of other 5 bags. calculated daily decomposition rates.
```{r}
Litter.decomposition <- list_raw_functions$Litter.decomposition
# take the mean daily decomposition rate over all measures, the ones with 2 months and the ones with 4 months decomposition.
Litter.decomposition <- aggregate(DailyDecompositionRate~EPPlotID,Litter.decomposition,mean)
data.table::setnames(Litter.decomposition, old=c("EPPlotID", "DailyDecompositionRate"), new=c("Plot", "Litter.decomposition"))
raw_functions <- merge(raw_functions, Litter.decomposition, by="Plot", all.x = T) ; rm(Litter.decomposition)
list_raw_functions["Litter.decomposition"] <- NULL
```


# Parasitoid traps
If there are more parasitoid wasps, they predate caterpillars which eat the plants.

In spring 2008, a total of 95 grassland plots were selected in Hainich-Dün, Schorfheide-Chorin and Schwäbische Alb. After collecting the traps at the end of September, nests of trap-nesting bees, wasps and their natural enemies were collected and recorded. The experimental grassland plots were chosen according to their different land use types and their distance from each other.

Cat : Replace by a better measure (caterpillars predation not found in bexis)

3 datasets (13350, 13347, 13349) for 3 regions: 34 from AEG, 28 from HEG and 34 from SEG - 96 plots measured

recorded total broodcell number : Total_BC_No
```{r}
# get dataset from raw functions list
pt <- list_raw_functions$Parasitoid.traps
pt <- pt[Function == "Parasitoid", c("PlotID", "Total_BC_No")]
pt <- aggregate(Total_BC_No~PlotID, pt, sum)
data.table::setnames(pt, old=c("PlotID", "Total_BC_No"), new=c("Plot", "Parasitoid.traps"))
# append to raw functions list
raw_functions <- merge(raw_functions, pt, by="Plot", all.x = T); rm(pt)
list_raw_functions["Parasitoid.traps"] <- NULL
```

# Total pollinators
Plot number AEG24 has 939 total pollinators in synthesis dataset, but only 339 total pollinators in the downloaded dataset. All other numbers are perfectly identical.

The number from the downloaded dataset is taken, but the change is recorded.
```{r}
Total.pollinators <- list_raw_functions$Total.pollinators
Total.pollinators <- aggregate(Total.pollinators~Plot, Total.pollinators, sum)
raw_functions <- merge(raw_functions, Total.pollinators, by="Plot", all=T) ; rm(Total.pollinators)
list_raw_functions["Total.pollinators"] <- NULL
```



# PRI
from synthesis .html : 

Phosphorus retention (PRI): Pmic (15766; microbial phosphorus in soil), PlantP.conc (18869; only 2009 data on P concentrations used and multiplied with biomass to give shoot.P.stock) and NaHCO3_Pi (5241) [PRI = (shoot.P.stock + Pmic)/(NaHCO3_Pi + Pmic + shoot.P.stock)]

*2014* : Pmic.2014, Pshoot.2013 (Biomass2013, Pshoot concentration 2013), Bulk.density2014

*2011* : ?

$$PRI = \frac{microbial Phosphorous + plant shoot Phosphorous}{microbial Phosphorous + plant shoot Phosphorous + soil Phosphorous}$$
where 
$$microbial Phosphorous = (Pmic (mg/kg) / 1000000) * (bulk density (g/cm^3) * 100000 cm^3/ m^2)$$
$$plant shoot P = Pshoot (\%) * Biomass (g/m^2) $$
$$soil P  = \frac{Olsen Pi (mg/kg)}{1000000} * (bulk density (g/cm^3) * 100000 cm^3/ m^2)$$

```{r}
# 2014
# Pmic.2014 Pshoot.2013, OlsenPi2014 in raw_functions
rPRI <- raw_functions[, c("Plot", "Pmic.2014", "Bulk.density2014", "OlsenPi2014", "Pshoot.2013", "Biomass2013")]
rPRI[, "micPstock":= (Pmic.2014 / 1000000)*(Bulk.density2014 * 100000)]
rPRI[, "soilPstock" := (OlsenPi2014 / 1000000) * (Bulk.density2014 * 100000)]
rPRI[, "plantPstock" := Pshoot.2013 * Biomass2013]
rPRI[, "PRI" := (micPstock + plantPstock)/(micPstock + plantPstock + soilPstock)]
raw_functions <- merge(raw_functions, rPRI[,c("Plot", "PRI")], by = "Plot", all = T) ; rm(rPRI)


# 2011
# could be done, but only using NaHCO3_Pi from 2008/2009
```


# pathogen infection
mean_prevalence : mean disease prevalence on plot averaged across all pathogens. The percentage of plants with visible infection symptoms.

mean_severity : mean disease severity on plot averaged across all pathogens. The percentage of aboveground plant surface affected by pathogen

**pathogen data :**
% infizierte pflanzen auf plot
% pflanzenoberfläche betroffen auf plot

**plant cover data :** % species cover in a 4x4 m plot
* total cover per plot is not 100, because plants can grow on top of each other. 
* normalisation because plant cover is estimated by different people

calculate total area infected by pathogens per plot: 
* total foliar pathogen infection (% plants infected x mean % infection per plant x %cover of plant)

```{r}
pathogen.infection <- list_raw_functions[["pathogen.infection"]]
plantcover <- list_raw_functions[["plantcover"]]

# calculate plant cover
plantcover <- data.table::as.data.table(aggregate(Cover~Plot, plantcover, sum))
plantcover[,"areaCover" := Cover * 2500 / 100]

# # normalisation across plots
# plantcover[,"normCover" := Cover / sum(Cover, na.rm=T)]
# # center around 1
# plantcover[, "centCover" := Cover - mean(plantcover$Cover)]
# dividemean
plantcover[, "divnormCover" := areaCover / mean(plantcover$areaCover)]
# standardisation (substract the mean and divide by sd)
plantcover[, "standCover" := scale(areaCover, center = T, scale = T)]

# merge datasets
pathogen.infection <- merge(pathogen.infection, plantcover, by = "Plot", all = T)

# calculate total foliar pathogen infection
# pathogen.infection[, "pathogen.infection" := normCover * (mean_prevalence/ 100) * (mean_severity/ 100)]
pathogen.infection[, "pathogen.infection" := standCover * ((mean_prevalence) * (mean_severity)/100) / 100]


# # problem with plto AEG4 : mean prevalence is 83.8 and mean severity is 43.4 - extremely high values !
# d[Plot == "AEG4", "pathogen.infection.x"] <- 0
# d[Plot == "AEG4", "pathogen.infection.y"] <- 0
# # not correlated neither



# # new approach: normalise fungi data
# pathogen.infection[, "normm_prevalence" := mean_prevalence / sum(mean_prevalence, na.rm=T)]
# pathogen.infection[, "normm_severity" := mean_severity / sum(mean_severity, na.rm=T)]
# pathogen.infection[, "pathogen.infection" := normCover * normm_prevalence * normm_severity]
# d <- merge(pathogen.infection, synthesis[, c("Plot", "pathogen.infection")])
# plot(d$pathogen.infection.x, d$pathogen.infection.y, xlim = c(0, 4e-06))
# # still not correlated

# TODO : not correlated with synthesis dataset! there must be an error somewhere... 
# or can it be because debi cleaned the plant cover data? 


list_raw_functions["pathogen.infection"] <- NULL
list_raw_functions["plantcover"] <- NULL
raw_functions <- merge(raw_functions, pathogen.infection[, c("Plot", "pathogen.infection")], by = "Plot", all = T) ; rm(pathogen.infection)
```

# dung decomposition
Taking the mean over all 5 dung types for each plot.
```{r}
dung.decomposition <- list_raw_functions[["dung.decomposition"]]
dung.decomposition <- aggregate(removal_g~EP, dung.decomposition, mean)
data.table::setnames(dung.decomposition, old = c("EP", "removal_g"), new=c("Plot", "dung.decomposition"))
raw_functions <- merge(raw_functions, dung.decomposition, by = "Plot", all = T) ; rm(dung.decomposition)
list_raw_functions["dung.decomposition"] <- NULL
```


# store assembled dataset
store as .csv document
```{r}
cat("Dear user, \n
    Please enter a prefix (=piece of the name which is printed in front of a file).\n
    It will be used for the assembled functions dataset.\n
    The dataset will be printed on your Desktop with the prefix you have given together with the following suffix :\n
    '_raw_functions_dataset.csv' \n
    example : 'december2018' would give 'december2018__raw_functions_dataset.csv'")
prefix <- readline(prompt="Write now : ")
write.csv(raw_functions, file=paste("~/Desktop/", prefix, "_raw_functions_dataset.csv", sep=""))
```

TODO : take out all functions which were only included to calculate others, e.g. Pmic 2011, 2014