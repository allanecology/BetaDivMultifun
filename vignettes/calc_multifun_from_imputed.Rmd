---
title: "mini-multifunctionalities from imputed functions"
author: "Noelle Schenk"
date: "June 5, 2019"
output: html_document
---
This script :
- calculates the multifunctionalities from the imputed functions dataset
- select functions for the analysis
- combine years
- calculate functional dissimilarity
```{r}
cols <- RColorBrewer::brewer.pal(8,"Dark2")
```

Requirements : 
- imputed_grlfuns : the imputed functions data


# Calculate mini-multifunctionalities
The mini-multifunctionalities are calculated from the imputed values.

## soilCflxs
Enzymes related to soil C. All measured in the year 2011.
```{r}
sce <- imputed_grlfuns[, c("beta_Glucosidase", "N_Acetyl_beta_Glucosaminidase", "Xylosidase")]
# take z-scores of the functions
imputed_grlfuns[, "soilCflxs" := multidiv(sce, sc="sd", cent=TRUE)[,1]]
imputed_grlfuns[, c("beta_Glucosidase", "N_Acetyl_beta_Glucosaminidase", "Xylosidase") := NULL]
rm(sce)
```

## about soil processes related to N

based on clustering and biology:
- ammonium is oxidised by bacteria and archaea (AOB, AOA)
- nitrate oxidation by bacteria (NS and NB)

these two steps are separated steps. The correlation of AO and NO is based on co-occurrence.

- ammonium oxidising group : AOA, AOB, urease (because this enzyme hydrolyses urea to ammonia and CO2)
- nitrate oxidising group : NS, NB, nifH, DEA.inverted
- potential nitrification is a separate process

## soilNitrateflxs
It could be that nitrospira and nitrobacter have slightly different habitat preferences --> sum their abundance as 'nitrite-oxidising functional gene abundance'. 

Inversion of DEA such that functions "point to same functional direction".
```{r}
nce <- imputed_grlfuns[,c("Plotn", "DEA.inverted","nifH", "nxrA_NS", "16S_NB")]
# sum abundances of nitrite oxidising functional genes
nce[, "nitOx_fga" := nxrA_NS + `16S_NB`]
nce[, c("nxrA_NS", "16S_NB") := NULL]

# mini-multifunctionality
imputed_grlfuns[, "soilNitrateflxs" := multidiv(nce[, !"Plotn", with=F], sc="sd", cent=T)[,1]]
rm(nce)
```

## soilAmmoniaflxs
```{r}
nce <- imputed_grlfuns[, c("Plotn", "Urease","amoA_AOB.2011","amoA_AOA.2011", "amoA_AOB.2016", "amoA_AOA.2016")]
# sum per year and take the mean of 2 years after
nce[, "amOX_fga2011" := amoA_AOB.2011 + amoA_AOA.2011]
nce[, "amOX_fga2016" := amoA_AOB.2016 + amoA_AOA.2016]
nce[, "amOX_fga" := apply(nce[,c("amOX_fga2011", "amOX_fga2016")],1, function(x) mean(x, na.rm = T))]
nce[, c("amOX_fga2011", "amOX_fga2016", "amoA_AOB.2011", "amoA_AOB.2016", "amoA_AOA.2011", "amoA_AOA.2016") := NULL]
imputed_grlfuns[, "soilAmmoniaflxs" := multidiv(nce[, !"Plotn", with=F], sc="sd", cent=T)[,1]]
rm(nce)
```

# Select functions
selecting the functions which are used in analysis.
```{r}
# select variables which are included in betadiv multifun analysis
usedforBetadivMultifun <- usedforBetadivMultifun[!usedforBetadivMultifun == "Plot"]
imputed_grlfuns <- imputed_grlfuns[, ..usedforBetadivMultifun]
# saveRDS(imputed_grlfuns, "imputed_and_compound_grlfuns.rds")
```

# Check Correlations
Of the non-factor columns only
```{r}
# the dataset is complete now, use "complete.obs" for the cor() function now
M <- cor(imputed_grlfuns[, !colnames(imputed_grlfuns) %in% "Plotn", with=F], use="complete.obs")

# imputed_grlfun_corrplot1
corrplot::corrplot(M,type="lower", addCoef.col = "black", method="color", diag=T, tl.srt=1, tl.col="black", mar=c(0,0,0,0), number.cex=0.2, order = "hclust", tl.cex = 0.3)

# imputed_grlfun_corrplot2
corrplot::corrplot(M, type = "upper", tl.col="black", tl.srt=40, diag = F,
                   tl.cex = 0.3, order = "hclust")

# only show high correlations
tres <- 0.7
M[which(M < tres & M > -tres)] <- 0
corrplot::corrplot(M, type = "upper", tl.col="black", tl.srt=40, diag = F, main = "B",
                   tl.cex = 0.3)
```

# Dissimilarity of single functions
This part of the script prepares the single function dissimilarities for the GDM models. Each function is fitted individually.

Dissimilarity between plots is the euclidean distance - which is just a substraction in the 1D case.

For each function : build dissimilarity matrix (euclidean distance) and then center & normalise
```{r}
# get a reference Table with the Plot combinations
singleEFdist <- data.table::data.table(t(combn(imputed_grlfuns$Plotn, 2)))
data.table::setnames(singleEFdist, old = c("V1", "V2"), new = c("Var1", "Var2"))

for(f in usedforBetadivMultifun[!usedforBetadivMultifun == "Plotn"]){
  # diffname <- paste("sEFdist", f, sep = "_")
  # print(diffname)
  small <- data.frame(imputed_grlfuns[, .(Plotn, get(f))])
  rownames(small) <- small$Plotn
  small$Plotn <- NULL
  diffsmall <- vegan::vegdist(small, method = "euclid")
  diffsmall <- as.matrix(diffsmall)
  diffsmall[!lower.tri(diffsmall)] <- NA
  diffsmall <- reshape2::melt(diffsmall, value.name = "X")
  diffsmall <- diffsmall[!is.na(diffsmall[, 3]),]
  diffsmall <- data.table::data.table(diffsmall)
  diffsmall[, eval(f) := scale(X, center = T)]
  diffsmall[, X := NULL]
  # assign(diffname, diffsmall)
  singleEFdist <- merge(singleEFdist, diffsmall, by = c("Var1", "Var2"), all.y = T)
  # saveRDS(diffsmall, file = paste(diffname, ".rds", sep = ""))
}
# standardisation
include <- colnames(singleEFdist)[!colnames(singleEFdist) %in% c("Var1", "Var2")]
singleEFdist[, (include) := lapply(.SD, scale01), .SDcols = include]

saveRDS(singleEFdist, "singleEFdist.rds")
```


# Dissimilarity of functions

2 ways of dissimilarity calculation : 
- *EFturnover* and *EFnestedness* : calculate presence-absence of functions by 0.5 treshold, and then calculate betadiversity turnover and nestedness components of them.
- *EFdistance* : calculate PCA, identify most important axis, take euclidean distance of them to get a single value for each plot. 
    - open question : weighting of the PCA axis. Weighting by var explained gives the correlated functions too much weight. Equal weighting? Is chosen until better option is available.


## EFdistance calculation

From PCA of all functions, take most important axes and calculate euclidian distance of them (using equal weights). Note : not weighed by amount of variance explained or similar, because soil axis should not get too much weight. 

We expect that one of the important axis - possibly the first to represent soil. As we have many soil functions compared to aboveground functions, soil would otherwise get too much importance.
```{r}
# STANDARDISATION
nimputed_grlfuns <- data.table::copy(imputed_grlfuns) # save an unscaled version for EFturnover / nestedness
include <- names(imputed_grlfuns)[!names(imputed_grlfuns) %in% "Plotn"]
imputed_grlfuns[, (include) := lapply(.SD, scale01),.SDcols=include]

# PCA
pc_grlfuns <- imputed_grlfuns[, ..include]
pc_grlfuns <- as.data.frame(pc_grlfuns)
rownames(pc_grlfuns) <- imputed_grlfuns$Plotn

pca_grlfuns <- stats::prcomp(pc_grlfuns, scale=F) 

# par(mfrow = c(2, 2))
plot(pca_grlfuns)
biplot(pca_grlfuns)
plot(ecdf(pca_grlfuns$sdev))
# dev.off()
```
Plotting first 5 axis
```{r, eval = F}
p <- plot(pca_grlfuns)
labelsize <- 3
p1 <- ggplot2::autoplot(pca_grlfuns, loadings = T, loadings.label= T, colour = "gray", loadings.colour = "black", 
               loadings.label.colour = "black", loadings.label.repel = T, loadings.label.size = labelsize)
p2 <- ggplot2::autoplot(pca_grlfuns, loadingsloadings = T, loadings.label= T, colour = "gray", loadings.colour = "black", 
               loadings.label.colour = "black", loadings.label.repel = T, loadings.label.size = labelsize,
               x = 3, y = 2)
p3 <- ggplot2::autoplot(pca_grlfuns, loadingsloadings = T, loadings.label= T, colour = "gray", loadings.colour = "gray", 
               loadings.label.colour = "black", loadings.label.repel = T, loadings.label.size = labelsize,
               x = 4, y = 3)
p4 <- ggplot2::autoplot(pca_grlfuns, loadingsloadings = T, loadings.label= T, colour = "gray", loadings.colour = "black", 
               loadings.label.colour = "black", loadings.label.repel = T, loadings.label.size = labelsize,
               x = 4, y = 5)
cowplot::plot_grid(plotlist = list(p1, p2, p3, p4), labels = c("A", "B", "C", "D"), align = T)

p5 <- ggplot2::autoplot(pca_grlfuns, loadingsloadings = T, loadings.label= T, colour = "gray", loadings.colour = "black", 
               loadings.label.colour = "black", loadings.label.repel = T,
               x = 5, y = 6)
```
```{r, eval = F}
rm(p); rm(p1); rm(p2); rm(p3); rm(p4); rm(p5)
```
**axis selection** : 
either first 3, 4 or 7 axes.
explained var : either 48%, 53.3 % or 64.6%

```{r}
pca_grlfuns <- pca_grlfuns$x[, 1:7]
#TODO : take first 4 or first 5 or first 7?
# euclidean distance
EFmaster <- vegan::vegdist(pca_grlfuns, method = "euclid")
EFmaster <- as.matrix(EFmaster)
EFmaster[!lower.tri(EFmaster)] <- NA
EFmaster <- reshape2::melt(EFmaster, value.name = "EFdistance")
EFmaster <- EFmaster[!is.na(EFmaster[, 3]),]
EFmaster <- data.table::data.table(EFmaster)
# standardise
EFmaster[, EFdistance := scale01(EFdistance)]
saveRDS(EFmaster, "EFdistance.rds")
rm(pca_grlfuns); rm(pc_grlfuns)
```


## EFturnover and EFnestedness
Based on a 50% treshold, classify for each function and each plot presence or absence of the given function. Based on the scaled functions.
```{r}
# percentage of measured functions that exceed a given treshold of their maximum observed level across all study sites.
# maximum observed level: average of the top five sites.
threshold <- 0.5
# tresholds used in Solivieres paper :  0.25,0.5,0.75,0.9
```
Plot for visualisation
```{r, eval = F}
# plot all 18 functions on one page
# x <- nimputed_grlfuns$Root.biomass
require(cowplot)

for(i in colnames(nimputed_grlfuns)[which(colnames(nimputed_grlfuns) != "Plotn")]){
  x <- nimputed_grlfuns[, get(i)]
  names(x) <- nimputed_grlfuns$Plotn
  # calc mean of top 5 values
  upper <- mean(sort(x, decreasing = T, na.last=T)[1:5])
  upperq <- quantile(x, probs = threshold)
  df <- cbind(len = x, deleteme = x)
  p <- ggplot2::ggplot(df, ggplot2::aes(y = len, x= rownames(df))) +
  ggplot2::geom_bar(stat="identity") +
  ggplot2::geom_abline(intercept = upper, slope = 0, color = "lightgray") +
  ggplot2::geom_abline(intercept = upper*threshold, slope = 0, color =cols[1]) +
  ggplot2::geom_abline(intercept = upperq, slope = 0, color = cols[2]) +
  theme(axis.text.x=element_blank()) + xlab("Plots") + ylab(i)
  plotname <- paste("plot", i, sep = "")
  assign(plotname, p)
  rm(p)
}
rm(i)

plotnames <- paste("plot", colnames(nimputed_grlfuns)[which(colnames(nimputed_grlfuns) != "Plotn")], sep = "")

plot_grid(plotlist = list(plotBiomass, plotdung.removal, plotGroundwater.recharge, plotherbivory.20172018, plotLitter.decomposition, plotN_leaching_risk2015, plotpathogen.infection, plotPhosphatase, plotPotential.nitrification, plotcaterpillars.predation, plotRoot.biomass, plotRoot.decomposition, plotseed.depletion, plotsoilCflxs, plotP_leaching_risk_comb, plotsoilNitrateflxs, plotsoilAmmoniaflxs),
          align = T)

# barplot(x, main="Root Biomass", xlab="Plots")
# abline(a=upper,b=0,col="lightgray")
# abline(a = upperq, b = 0, col = "darkgreen")
# abline(a=upper*threshold, b=0, col="orange")

rm(df); rm(plotBiomass, plotdung.removal, plotGroundwater.recharge, plotherbivory.20172018, plotLitter.decomposition, plotN_leaching_risk2015, plotpathogen.infection, plotPhosphatase, plotPotential.nitrification, plotcaterpillars.predation, plotRoot.biomass, plotRoot.decomposition, plotseed.depletion, plotsoilCflxs, plotP_leaching_risk_comb, plotsoilNitrateflxs, plotsoilAmmoniaflxs)
```

With threshold max 5 method
```{r}
include <- names(nimputed_grlfuns)[!names(nimputed_grlfuns) %in% "Plotn"]
pa_grlfuns <- data.table::copy(nimputed_grlfuns)  # dataset for max 5 functions
threshold <- 0.8
```
Note : to make EF master for all thresholds : change manually above and run again and again the chunk below.
```{r}
# CONVERT TO PRESENCE ABSENCE
pa_grlfuns[, (include) := lapply(.SD, function(c) calc_presenceabsence(c, threshold = threshold, type = "max5")), .SDcols = include]
pa_grlfuns[, (include) := (.SD * 1), .SDcols = include]

# CALC BETADIVERSITY
pa_grlfuns <- data.frame(pa_grlfuns[, !"Plotn", with=F], row.names = pa_grlfuns$Plotn)
pa_grlfuns <- betapart::beta.pair(pa_grlfuns, index.family = "sorensen")

EFbeta <- pa_grlfuns$beta.sor
t <- as.matrix(EFbeta)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = paste("EFbeta", threshold, sep = "_"))
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

EFturnover <- pa_grlfuns$beta.sim
t <- as.matrix(EFturnover)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = paste("EFturnover", threshold, sep = "_"))
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

EFnestedness <- pa_grlfuns$beta.sne
t <- as.matrix(EFnestedness)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = paste("EFnestedness", threshold, sep = "_"))
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))
```
standardise and save
```{r}
# saveRDS(EFturnover, "EFturnover.rds")
# saveRDS(EFnestedness, "EFnestedness.rds")
saveRDS(EFmaster, "EFmaster.rds")
```


Plot components of EFbeta
```{r, eval = F}
# # check EFmaster
# EFcheck <- data.table::copy(data.table::data.table(EFmaster))
# EFcheck[, "check" := EFturnover + EFnestedness - EFbeta]
# plot(EFcheck$check, ylim = c(-1, 1))
# rm(EFcheck)
# TRUE : EFturnover + EFnestedness - EFbeta is always 0 (or very near 0)

plotEFbeta <- reshape2::melt(EFmaster[, c("Var1", "Var2", "EFbeta_0.5", "EFturnover_0.5", "EFnestedness_0.5")], id = c("Var1", "Var2"))
p <- ggplot2::ggplot(data = plotEFbeta, aes(x = variable, y = value)) +
  geom_violin() + geom_jitter(shape=".", position=position_jitter(0.2), color = "gray") + 
  labs(title="Threshold-based dissimiliarity of Ecosystem Functions", subtitle = "threshold = 0.5", xlab = "") + 
  scale_x_discrete(labels=c("beta", "turnover", "nestedness")) +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank())
```


With quantile method
```{r, eval=F}
include <- names(nimputed_grlfuns)[!names(imputed_grlfuns) %in% "Plotn"]
paq_grlfuns <- data.table::copy(nimputed_grlfuns) # dataset for quantile functions

# CONVERT TO PRESENCE ABSENCE
# quantile method
paq_grlfuns[, (include) := lapply(.SD, function(c) calc_presenceabsence(c, threshold = threshold, type = "quantile")), .SDcols = include]
paq_grlfuns[, (include) := (.SD * 1), .SDcols = include]

# CALC BETADIVERSITY
paq_grlfuns <- data.frame(paq_grlfuns[, !"Plotn", with = F], row.names = paq_grlfuns$Plotn)
paq_grlfuns <- betapart::beta.pair(paq_grlfuns, index.family = "sorensen")

EFturnoverQ <- paq_grlfuns$beta.sim
t <- as.matrix(EFturnoverQ)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFturnover_median")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

EFnestednessQ <- paq_grlfuns$beta.sne
t <- as.matrix(EFnestednessQ)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFnestedness_median")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

EFbetaQ <- paq_grlfuns$beta.sor
t <- as.matrix(EFbetaQ)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFbeta_median")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

saveRDS(EFmaster, "EFquantile_median.rds")
```

# abundance betadiversity
Abundance betadiversity of z-scores of functions.
```{r}
abund_grlfuns <- data.table::copy(nimputed_grlfuns) # dataset for quantile functions
# CALC BETADIVERSITY
abund_grlfuns <- data.frame(abund_grlfuns[, !"Plotn", with = F], row.names = abund_grlfuns$Plotn)
# scale to be between 0 and 1000 (promille) and round to 0 decimals
#  betapart does not allow negative values, and decimals do not make sense.
abund_grlfuns <- apply(abund_grlfuns, 2, function(x) round(scale01(x)*1000, digits = 0))

abund_grlfuns <- betapart::beta.pair.abund(abund_grlfuns, index.family = "bray")

temp <- abund_grlfuns$beta.bray
t <- as.matrix(temp)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFabund_bray")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

temp <- abund_grlfuns$beta.bray.bal
t <- as.matrix(temp)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFabund_bray_bal")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

temp <- abund_grlfuns$beta.bray.gra
t <- as.matrix(temp)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFabund_bray_gra")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

saveRDS(EFmaster, "EFbeta_abund.rds")
```


```{r}
rm(nimputed_grlfuns); rm(imputed_grlfuns); rm(pa_grlfuns); rm(raw_grlfuns)
rm(include)
rm(p); rm(cols); rm(tres); rm(threshold); rm(upper); rm(upperq); rm(x)
```
