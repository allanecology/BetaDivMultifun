---
title: "mini-multifunctionalities from imputed functions"
author: "Noelle Schenk"
date: "June 5, 2019"
output: html_document
---
This script :
- calculates the multifunctionalities from the imputed functions dataset
- select functions for the analysis
- combine years
- calculate functional dissimilarity
```{r}
cols <- RColorBrewer::brewer.pal(8,"Dark2")
```

Requirements : 
- imputed_grlfuns : the imputed functions data


# Calculate mini-multifunctionalities
The mini-multifunctionalities are calculated from the imputed values.

## soilCflxs
Enzymes related to soil C. All measured in the year 2011.
```{r}
sce <- imputed_grlfuns[, c("beta_Glucosidase", "N_Acetyl_beta_Glucosaminidase", "Xylosidase")]
# take z-scores of the functions
imputed_grlfuns[, "soilCflxs" := multidiv(sce, sc="sd", cent=TRUE)[,1]]
imputed_grlfuns[, c("beta_Glucosidase", "N_Acetyl_beta_Glucosaminidase", "Xylosidase") := NULL]
rm(sce)
```

## about soil processes related to N

based on clustering and biology:
- ammonium is oxidised by bacteria and archaea (AOB, AOA)
- nitrate oxidation by bacteria (NS and NB)

these two steps are separated steps. The correlation of AO and NO is based on co-occurrence.

- ammonium oxidising group : AOA, AOB, urease (because this enzyme hydrolyses urea to ammonia and CO2)
- nitrate oxidising group : NS, NB, nifH, DEA
- potential nitrification is a separate process

## soilNitrateflxs
It could be that nitrospira and nitrobacter have slightly different habitat preferences --> sum their abundance as 'nitrite-oxidising functional gene abundance'. 

Inversion of DEA such that functions "point to same functional direction".
```{r}
nce <- imputed_grlfuns[,c("Plotn", "nitrate.production.availability","nifH", "nxrA_NS", "16S_NB")]
# sum abundances of nitrite oxidising functional genes
nce[, "nitOx_fga" := nxrA_NS + `16S_NB`]
nce[, c("nxrA_NS", "16S_NB") := NULL]

# mini-multifunctionality
imputed_grlfuns[, "soilNitrateflxs" := multidiv(nce[, !"Plotn", with=F], sc="sd", cent=T)[,1]]
rm(nce)
```

## soilAmmoniaflxs
```{r}
nce <- imputed_grlfuns[, c("Plotn", "Urease","amoA_AOB.2011","amoA_AOA.2011", "amoA_AOB.2016", "amoA_AOA.2016")]
# take mean of multi-year-measurements
nce[, "amoA_AOB" := apply(nce[,c("amoA_AOB.2011", "amoA_AOB.2016")],1, function(x) mean(x, na.rm = T))]
nce[, "amoA_AOA" := apply(nce[,c("amoA_AOA.2011", "amoA_AOA.2016")],1, function(x) mean(x, na.rm = T))]
nce[, "amm-ox_funct_gene_abund" := amoA_AOB + amoA_AOA]
nce[, c("amoA_AOB", "amoA_AOA", "amoA_AOB.2011", "amoA_AOB.2016", "amoA_AOA.2011", "amoA_AOA.2016") := NULL]
imputed_grlfuns[, "soilAmmoniaflxs" := multidiv(nce[, !"Plotn", with=F], sc="sd", cent=T)[,1]]
rm(nce)
```


# P_loss_comb
```{r}
#TODO : P_loss_comb is excluded at the moment, only PRIcomb and P_leaching_risk_comb are used

# plc <- imputed_grlfuns[, c("P_loss2011", "P_leaching_risk2015", "PRI", "PRI.2011")]
# # take mean of P_loss 2011 and leaching risk 2015
# plc[, "P_loss" := apply(plc[,c("P_loss2011", "P_leaching_risk2015")],1, mean)]
# plc[, c("P_loss2011", "P_leaching_risk2015") := NULL]
# # take mean of PRI
# plc[, "PRIc" := apply(plc[, c("PRI", "PRI.2011")], 1, mean)]
# plc[, c("PRI", "PRI.2011") := NULL]
# data.table::setnames(plc, old = "PRIc", new = "PRI")
# 
# imputed_grlfuns[, "P_loss_comb" := multidiv(plc, sc="sd", cent=TRUE)[,1]]
# 
# rm(plc)
# imputed_grlfuns[, c("P_loss2011", "P_leaching_risk2015", "PRI", "PRI.2011") := NULL]
```


# Select functions
selecting the functions which are used in analysis.
```{r}
# select variables which are included in betadiv multifun analysis
usedforBetadivMultifun <- usedforBetadivMultifun[!usedforBetadivMultifun == "Plot"]
#TODO : update
# usedforBetadivMultifun <- c(usedforBetadivMultifun[- which(usedforBetadivMultifun == "soilNflxs")], "soilAmmoniaflxs", "soilNitrateflxs")
usedforBetadivMultifun <- c(usedforBetadivMultifun[- which(usedforBetadivMultifun %in% c("PRI", "PRI.2011", "P_leaching_risk2015", "P_loss2011"))], "soilAmmoniaflxs", "soilNitrateflxs")

imputed_grlfuns <- imputed_grlfuns[, ..usedforBetadivMultifun]
#TODO : save functions?
# saveRDS(imputed_grlfuns, "imputed_grlfuns.rds")
```

# Check Correlations
Of the non-factor columns only
```{r}
# the dataset is complete now, use "complete.obs" for the cor() function now
M <- cor(imputed_grlfuns[, !colnames(imputed_grlfuns) %in% "Plotn", with=F], use="complete.obs")

# imputed_grlfun_corrplot1
corrplot::corrplot(M,type="lower",addCoef.col = "black",method="color",diag=F, tl.srt=1, tl.col="black", mar=c(0,0,0,0), number.cex=0.6)

# imputed_grlfun_corrplot2
corrplot::corrplot(M, type = "upper", tl.col="black", tl.srt=40, diag = F)

# only show high correlations
tres <- 0.7
M[which(M < tres & M > -tres)] <- 0
corrplot::corrplot(M, type = "upper", tl.col="black", tl.srt=40, diag = F, main = "B")
```

# Dissimilarity of single functions
This part of the script prepares the single function dissimilarities for the GDM models. Each function is fitted individually.

Dissimilarity between plots is the euclidean distance - which is just a substraction in the 1D case.
```{r}
#TODO calculate dissimilarities for single functions and save as RDS for GDM.
# see p. 65
#HERE!


```


# Dissimilarity of functions

2 ways of dissimilarity calculation : 
- *EFturnover* and *EFnestedness* : calculate presence-absence of functions by 0.5 treshold, and then calculate betadiversity turnover and nestedness components of them.
- *EFdistance* : calculate PCA, identify most important axis, take euclidean distance of them to get a single value for each plot. 
    - open question : weighting of the PCA axis. Weighting by var explained gives the correlated functions too much weight. Equal weighting? Is chosen until better option is available.


## EFdistance calculation

From PCA of all functions, take most important axes and calculate euclidian distance of them (using equal weights). Note : not weighed by amount of variance explained or similar, because soil axis should not get too much weight. 

We expect that one of the important axis - possibly the first to represent soil. As we have many soil functions compared to aboveground functions, soil would otherwise get too much importance.
```{r}
# STANDARDISATION
nimputed_grlfuns <- data.table::copy(imputed_grlfuns) # save an unscaled version for EFturnover / nestedness
include <- names(imputed_grlfuns)[!names(imputed_grlfuns) %in% "Plotn"]
imputed_grlfuns[, (include) := lapply(.SD, scale01),.SDcols=include]

# PCA
pc_grlfuns <- imputed_grlfuns[, ..include]
pc_grlfuns <- as.data.frame(pc_grlfuns)
rownames(pc_grlfuns) <- imputed_grlfuns$Plotn

pca_grlfuns <- stats::prcomp(pc_grlfuns, scale=F) 

plot(pca_grlfuns)
biplot(pca_grlfuns)
plot(ecdf(pca_grlfuns$sdev))
```
**axis selection** : 
first 5 axis explain 70 % of variance

There are groups of three axis which have about the same amount of variance explained. 
```{r}
pca_grlfuns <- pca_grlfuns$x[, 1:5]
# euclidean distance
EFmaster <- vegan::vegdist(pca_grlfuns, method = "euclid")
EFmaster <- as.matrix(EFmaster)
EFmaster[!lower.tri(EFmaster)] <- NA
EFmaster <- reshape2::melt(EFmaster, value.name = "EFdistance")
EFmaster <- EFmaster[!is.na(EFmaster[, 3]),]
# saveRDS(EFdistance, "EFdistance.rds")
rm(pca_grlfuns); rm(pc_grlfuns)
```


## EFturnover and EFnestedness
Based on a 50% treshold, classify for each function and each plot presence or absence of the given function. Based on the scaled functions.

TODO Without scaling - in old analysis it was scaled ... check if it works without `nimputed_grlfuns`
```{r}
# percentage of measured functions that exceed a given treshold of their maximum observed level across all study sites.
# maximum observed level: average of the top five sites.
threshold <- 0.5
# tresholds used in Solivieres paper :  0.25,0.5,0.75,0.9
#TODO : use more thresholds
```
Plot for visualisation
```{r}
x <- nimputed_grlfuns$Root.biomass
names(x) <- nimputed_grlfuns$Plotn

# calc mean of top 5 values
upper <- mean(sort(x, decreasing = T, na.last=T)[1:5])
upperq <- quantile(x, probs = threshold)

barplot(x, main="Root Biomass", xlab="Plots")
abline(a=upper,b=0,col="lightgray")
abline(a = upperq, b = 0, col = "darkgreen")
abline(a=upper*threshold, b=0, col="orange")

require(cowplot)
df <- cbind(len = x, deleteme = x)
p <- ggplot2::ggplot(df, ggplot2::aes(y = len, x= rownames(df))) +
  ggplot2::geom_bar(stat="identity") +
  ggplot2::geom_abline(intercept = upper, slope = 0, color = "lightgray") +
  ggplot2::geom_abline(intercept = upper*threshold, slope = 0, color =cols[1]) +
  ggplot2::geom_abline(intercept = upperq, slope = 0, color = cols[2]) +
  theme(axis.text.x=element_blank()) + xlab("Plots") + ylab("Root biomass [g]") 
rm(df)
```

With max 5 method
```{r}
include <- names(nimputed_grlfuns)[!names(imputed_grlfuns) %in% "Plotn"]
pa_grlfuns <- data.table::copy(nimputed_grlfuns)  # dataset for max 5 functions

# CONVERT TO PRESENCE ABSENCE
pa_grlfuns[, (include) := lapply(.SD, function(c) calc_presenceabsence(c, threshold = threshold, type = "max5")), .SDcols = include]
pa_grlfuns[, (include) := (.SD * 1), .SDcols = include]

# CALC BETADIVERSITY
pa_grlfuns <- data.frame(pa_grlfuns[, !"Plotn", with=F], row.names = pa_grlfuns$Plotn)
pa_grlfuns <- betapart::beta.pair(pa_grlfuns, index.family = "sorensen")

EFturnover <- pa_grlfuns$beta.sim
t <- as.matrix(EFturnover)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFturnover")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

EFnestedness <- pa_grlfuns$beta.sne
t <- as.matrix(EFnestedness)
t[!lower.tri(t)] <- NA
t <- reshape2::melt(t, value.name = "EFnestedness")
t <- t[!is.na(t[, 3]), ]
EFmaster <- merge(EFmaster, t, by = c("Var1", "Var2"))

# saveRDS(EFturnover, "EFturnover.rds")
# saveRDS(EFnestedness, "EFnestedness.rds")
saveRDS(EFmaster, "EFmaster.rds")
```

With quantile method
```{r, eval=F}
include <- names(nimputed_grlfuns)[!names(imputed_grlfuns) %in% "Plotn"]
paq_grlfuns <- data.table::copy(nimputed_grlfuns) # dataset for quantile functions

# CONVERT TO PRESENCE ABSENCE
# quantile method
paq_grlfuns[, (include) := lapply(.SD, function(c) calc_presenceabsence(c, threshold = threshold, type = "quantile")), .SDcols = include]
paq_grlfuns[, (include) := (.SD * 1), .SDcols = include]

# CALC BETADIVERSITY
paq_grlfuns <- data.frame(paq_grlfuns[, !"Plotn", with = F], row.names = paq_grlfuns$Plotn)
paq_grlfuns <- betapart::beta.pair(paq_grlfuns, index.family = "sorensen")
EFturnoverQ <- paq_grlfuns$beta.sim
EFnestednessQ <- paq_grlfuns$beta.sne

saveRDS(EFturnoverQ, "EFturnoverQ.rds")
saveRDS(EFnestednessQ, "EFnestednessQ.rds")
```

```{r}
rm(nimputed_grlfuns); rm(imputed_grlfuns); rm(pa_grlfuns); rm(paq_grlfuns); rm(raw_grlfuns)
rm(include)
rm(p); rm(cols); rm(tres); rm(threshold); rm(upper); rm(upperq); rm(x)
```
